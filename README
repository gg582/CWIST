# CWIST - C Web development Is Still Trustworthy

CWIST is a modern, lightweight C web framework designed for building secure and scalable applications. It brings the ergonomics of modern web frameworks to C without sacrificing performance or control.

== FEATURES ==

- HTTP/1.1 Server: Robust request parsing and response handling.
- SString: Custom string library with compare and substr support.
- WebSocket Support: Easy upgrade from HTTP to persistent connections.
- Middleware System: Chainable processing for logging and security.
- Path Parameters: Express-style routing with :param support and Mux Router.
- JSON Builder: Lightweight utility using cJSON for response building.
- Static Assets & DB Sharing: Serve directories with `cwist_app_static` and reuse SQLite handles via `cwist_app_use_db`.
- Nuke DB: High-performance In-Memory SQLite with persistent disk synchronization (`cwist_nuke_init`).
- Secure by Design: Built-in integration with Monocypher.

== QUICK START ==

1. Installation:
$ git clone [https://github.com/your/cwist.git](https://github.com/your/cwist.git)
$ cd cwist
$ make install

2. Hello World (main.c):

====================================== code ===================================
| #include <cwist/sys/app/app.h>                                              |
| #include <cwist/core/sstring/sstring.h>                                     |
|                                                                             |
| void index_handler(cwist_http_request *req, cwist_http_response *res) {     |
|     cwist_sstring_assign(res->body, "Hello from CWIST!");                   |
| }                                                                           |
|                                                                             |
| int main() {                                                                |
|     cwist_app *app = cwist_app_create();                                    |
|     cwist_app_use_db(app, ":memory:");                                      |
|     cwist_app_get(app, "/", index_handler);                                 |
|     cwist_app_listen(app, 8080);                                            |
|     cwist_app_destroy(app);                                                 |
|     return 0;                                                               |
| }                                                                           |
===============================================================================

3. Compilation:
$ gcc -o server main.c -lcwist -lssl -lcrypto -luriparser -lcjson -ldl -lpthread
$ ./server

== NUKE DB ==

Nuke DB is a **Read-Optimal Persistent Store**. It follows a "Read-from-RAM, Write-to-Disk" philosophy:
- **Ultra-Fast Reads**: All queries are executed against an in-memory SQLite instance, providing sub-millisecond response times for read-heavy workloads.
- **Reliable Writes**: Every `COMMIT` triggers an immediate background synchronization to the physical disk (WAL mode), ensuring your data is safe even if the process crashes.
- **Trade-off**: While write performance is slightly affected by disk I/O synchronization, the system guarantees that reads remain unblocked and consistently fast.
- **Raw Bootstrap**: On startup, the on-disk SQLite file is read directly as a raw image (`sqlite3_deserialize`) so the in-memory copy is hydrated without walking through the backup API.
- **Integrity Guard**: Each bootstrap runs `PRAGMA integrity_check` against the disk database and aborts if corruption is detected.
- **Safe Fallback**: When the diskâ†’memory transfer fails, Nuke DB switches to the disk handle so missing-row lookups never crash or read from uninitialised memory.

Usage:
1. `cwist_nuke_init("data.db", 5000);` // Loads data.db to memory, enables auto-sync every 5s + immediate sync on commit.
2. Use `cwist_nuke_get_db()` to access the high-speed in-memory handle.
3. On application exit (SIGINT/SIGTERM), Nuke DB performs a final safety sync.
4. **Safety**: If the initial load from disk fails (corrupted file), Nuke DB enters a read-only disk protection mode to prevent overwriting your data.

== LIBTTAK PERFORMANCE CORE ==

CWIST links against the in-tree `lib/libttak` build and now exposes the subsystems that landed with the latest drop.

### Generational Arena Allocator
- Static assets (`cwist_app_static`) and Big Dumb Reply blobs are staged in a tracked arena backed by `ttak_mem_tree`. Replacements do not fragment RSS because each generation is released in one shot.
- The allocator honors cache-aligned chunks and keeps separate hot/warm rows (see `lib/libttak/tutorials/40-arena-memory`) so high-churn endpoints recycle buffers without calling `malloc`/`free` under load.

### Epoch-Based Reclamation (EBR)
- Threads pin critical sections with `ttak_epoch_enter/exit` so arena generations can be retired without locking readers.
- `cwist_fix_server_mem` and the new examples advance epochs during hot reloads; stale buffers are reclaimed the moment no worker is in that epoch, which keeps latency flat even when static files churn.

### Detachable Memory
- `ttak_detachable_mem_alloc` layers a tiny-cache + signal-safe arena on top of EBR. CWIST uses it for TLS write buffers, websocket frames, and zero-copy HTTP responses.
- The detachable cache short-circuits the allocator for tiny payloads (<=16B) while larger slices flow through the same generational rows, so the server sustains >15M ops/s (see `lib/libttak/bench/ttl-cache-multithread-bench`).

### Big Dumb Reply Guardrails
- The built-in BDR cache now enforces a rolling sweep that expires entries after 5 minutes or ~100k hits and caps the live payload budget at 32 MiB by default. Oldest blobs are trimmed automatically so a long-running server never hoards stale pages.
- Tune the policy per app with `cwist_app_configure_bdr(app, CWIST_MIB(16), 60, 5000)` or globally through `cwist_bdr_set_limits` if you are wiring the cache manually.

### RPS Showcase Example
- `example/rps-showcase/` is a new high-throughput demo that keeps a JSON payload inside a detachable arena, protects it with EBR, and streams it via `cwist_http_response_set_body_ptr`.
- Run `wrk -t4 -c128 -d30s http://127.0.0.1:8080/rps` inside that folder to see how swapping payload generations does not interrupt live traffic.

== DEPENDENCIES ==

- cJSON ([https://github.com/DaveGamble/cJSON](https://github.com/DaveGamble/cJSON))
- OpenSSL (libssl, libcrypto)
- uriparser
- libttak ([https://github.com/gg582/libttak](https://github.com/gg582/libttak))
- (SQLite3 is now statically embedded)

== PAST ROADMAP ==

- Security: CORS middleware and origin / header policy management.
- RestAPI: Dedicated features for optimized RestAPI server deployment.
